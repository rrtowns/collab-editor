<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rick's Docs</title>
  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,400&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      background: #f8f6f3;
      font-family: 'DM Sans', 'Segoe UI', system-ui, sans-serif;
    }

    /* Header */
    .header {
      background: #fff;
      border-bottom: 1px solid #e8e5e0;
      padding: 14px 32px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .header-left { display: flex; align-items: center; gap: 12px; }
    .logo {
      width: 28px; height: 28px; border-radius: 7px;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      display: flex; align-items: center; justify-content: center;
      color: #fff; font-size: 14px; font-weight: 700;
    }
    .header-title { font-size: 15px; font-weight: 600; color: #1e293b; }
    .header-status { font-size: 12px; color: #94a3b8; margin-left: 4px; }
    .header-actions { display: flex; gap: 6px; }

    .btn {
      padding: 5px 12px; font-size: 12px; font-weight: 600;
      border-radius: 6px; cursor: pointer;
      font-family: 'DM Sans', sans-serif;
      border: none; transition: opacity 0.15s;
    }
    .btn:hover { opacity: 0.85; }
    .btn-reject {
      color: #dc2626; background: transparent;
      border: 1px solid rgba(220, 38, 38, 0.2);
    }
    .btn-accept { color: #fff; background: #16a34a; }
    .btn-revise {
      color: #fff; padding: 5px 14px;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      box-shadow: 0 1px 3px rgba(99, 102, 241, 0.3);
    }
    .btn-revise:disabled, .btn-new:disabled, .btn-reject:disabled,
    .btn-accept:disabled, .model-select:disabled {
      opacity: 0.5; cursor: not-allowed;
    }

    /* Banner */
    .banner {
      max-width: 1060px; margin: 16px auto 0; padding: 10px 16px;
      background: rgba(99, 102, 241, 0.05);
      border: 1px solid rgba(99, 102, 241, 0.12);
      border-radius: 8px; display: flex; align-items: center; gap: 10px;
      font-size: 13px; color: #475569; line-height: 1.5;
    }
    .banner-close {
      background: none; border: none; cursor: pointer;
      color: #94a3b8; font-size: 16px; padding: 0;
    }

    /* Layout */
    .layout {
      max-width: 1060px; margin: 20px auto;
      display: flex; gap: 16px; align-items: flex-start;
    }

    /* Document */
    .document {
      padding: 48px 48px 80px; background: #fff;
      border-radius: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.03);
      border: 1px solid #e8e5e0; min-height: 420px; cursor: text;
    }
    .paragraph {
      font-family: 'Source Serif 4', Georgia, serif;
      font-size: 17px; line-height: 1.9; color: #1e293b;
      margin: 0 0 24px 0; white-space: pre-wrap;
    }
    .paragraph[contenteditable="true"], .paragraph-editing { outline: none; }
    .paragraph[contenteditable="true"]:empty::before,
    .paragraph-editing:empty::before {
      content: "Start writing here...";
      color: #94a3b8; font-style: italic;
      pointer-events: none;
    }
    .document[contenteditable="true"] { outline: none; }

    /* Highlights */
    .highlight {
      border-radius: 2px; cursor: pointer; padding: 1px 0;
      transition: outline 0.15s ease;
    }
    .highlight.active { outline-offset: 1px; }

    ::highlight(pending-comment) {
      background: rgba(99, 102, 241, 0.15);
    }

    /* Tracked changes inline */
    .change-old {
      text-decoration: line-through; color: #b91c1c;
      background: rgba(239, 68, 68, 0.07); border-radius: 2px;
      text-decoration-color: #dc2626;
    }
    .change-arrow { color: #94a3b8; margin: 0 3px; font-size: 14px; }
    .change-new {
      color: #15803d; background: rgba(34, 197, 94, 0.08); border-radius: 2px;
    }
    .change-flash {
      background: rgba(34, 197, 94, 0.1); border-radius: 2px;
      transition: background 1.2s ease;
    }

    .change-btn {
      width: 20px; height: 20px; border-radius: 4px;
      font-size: 12px; cursor: pointer;
      display: inline-flex; align-items: center; justify-content: center;
      padding: 0; line-height: 1; vertical-align: middle;
      position: relative; top: -1px; margin-left: 2px;
    }
    .change-btn-accept {
      background: rgba(22, 163, 74, 0.1);
      border: 1px solid rgba(22, 163, 74, 0.25);
      color: #16a34a;
    }
    .change-btn-reject {
      background: rgba(220, 38, 38, 0.06);
      border: 1px solid rgba(220, 38, 38, 0.18);
      color: #dc2626; font-size: 11px;
    }

    /* Comment popover */
    .popover {
      position: fixed; z-index: 100; background: #fff;
      border-radius: 10px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.12), 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid #e2e8f0; padding: 12px; width: 280px;
    }
    .popover textarea {
      width: 100%; min-height: 56px; padding: 8px; font-size: 13px;
      font-family: 'DM Sans', system-ui, sans-serif;
      border: 1px solid #e2e8f0; border-radius: 6px;
      resize: vertical; outline: none; line-height: 1.5; color: #334155;
    }
    .popover textarea:focus { border-color: #6366f1; }
    .popover-actions {
      display: flex; justify-content: flex-end; gap: 6px; margin-top: 8px;
    }
    .popover-cancel {
      padding: 5px 12px; font-size: 12px; font-weight: 500;
      color: #64748b; background: #f1f5f9;
      border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer;
    }
    .popover-submit {
      padding: 5px 12px; font-size: 12px; font-weight: 600;
      color: #fff; background: #6366f1;
      border: none; border-radius: 6px; cursor: pointer;
    }
    .popover-submit:disabled { background: #a5b4fc; cursor: default; }

    /* Selection toolbar (Google Docs-style) */
    .selection-toolbar {
      position: fixed; z-index: 100;
      display: none; flex-direction: column; align-items: center;
      background: #fff; border-radius: 24px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.12), 0 0 0 1px rgba(0,0,0,0.04);
      padding: 4px;
    }
    .selection-toolbar.visible { display: flex; }
    .selection-toolbar button {
      width: 36px; height: 36px; border-radius: 50%;
      border: none; background: transparent; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      color: #6366f1; font-size: 18px;
      transition: background 0.15s;
    }
    .selection-toolbar button:hover { background: rgba(99,102,241,0.08); }

    /* Comment card (floating) */
    .comment-card {
      position: fixed; z-index: 101; background: #fff;
      border-radius: 10px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.12), 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid #e2e8f0; padding: 12px; width: 280px;
      display: none;
    }
    .comment-card.visible { display: block; }
    .comment-card textarea {
      width: 100%; min-height: 56px; padding: 8px; font-size: 13px;
      font-family: 'DM Sans', system-ui, sans-serif;
      border: 1px solid #e2e8f0; border-radius: 6px;
      resize: vertical; outline: none; line-height: 1.5; color: #334155;
    }
    .comment-card textarea:focus { border-color: #6366f1; }
    .comment-card-actions {
      display: flex; justify-content: flex-end; gap: 6px; margin-top: 8px;
    }

    /* Sidebar */
    .sidebar { flex: 0 0 220px; min-width: 220px; position: relative; overflow: hidden; }
    .sidebar-title {
      font-size: 11px; font-weight: 700; color: #94a3b8;
      text-transform: uppercase; letter-spacing: 0.06em;
      margin-bottom: 0;
    }
    .margin-comment {
      position: absolute; left: 0; right: 0;
      padding: 8px 10px;
      border-radius: 0 6px 6px 0; cursor: pointer;
      transition: all 0.15s ease;
    }
    .margin-comment-quote {
      font-size: 11px; color: #94a3b8; margin-bottom: 3px;
      font-weight: 500; display: flex; justify-content: space-between;
      align-items: center; font-style: italic;
    }
    .margin-comment-text {
      font-size: 13px; color: #334155; line-height: 1.45;
    }
    .margin-comment-delete {
      background: none; border: none; color: #cbd5e1;
      cursor: pointer; font-size: 14px; padding: 0 2px; line-height: 1;
    }

    /* Loading overlay */
    .loading-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.15);
      z-index: 200; display: flex; align-items: center; justify-content: center;
      backdrop-filter: blur(2px);
    }
    .loading-box {
      background: #fff; border-radius: 14px; padding: 32px 40px;
      box-shadow: 0 8px 40px rgba(0,0,0,0.15);
      text-align: center;
    }
    .spinner {
      width: 32px; height: 32px; border: 3px solid #e2e8f0;
      border-top-color: #6366f1; border-radius: 50%;
      animation: spin 0.8s linear infinite; margin: 0 auto 16px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Toast */
    .toast {
      position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
      background: #1e293b; color: #fff; padding: 10px 20px;
      border-radius: 8px; font-size: 13px; font-weight: 500;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 300;
      animation: fadeInUp 0.3s ease;
    }
    .toast.error { background: #dc2626; }
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateX(-50%) translateY(8px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Model picker */
    .model-select {
      padding: 4px 8px; font-size: 12px; font-weight: 500;
      font-family: 'DM Sans', sans-serif;
      border: 1px solid #e2e8f0; border-radius: 6px;
      background: #f8fafc; color: #475569; cursor: pointer;
      outline: none; appearance: auto;
    }
    .model-select:focus { border-color: #6366f1; }

    /* New document button */
    .btn-new {
      color: #64748b; background: transparent;
      border: 1px solid #e2e8f0;
    }

    /* Empty state */
    .empty-state {
      max-width: 600px; margin: 80px auto; padding: 48px;
      background: #fff; border-radius: 14px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.03);
      border: 1px solid #e8e5e0; text-align: center;
    }
    .empty-state-icon {
      width: 56px; height: 56px; border-radius: 14px;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      display: inline-flex; align-items: center; justify-content: center;
      color: #fff; font-size: 24px; font-weight: 700; margin-bottom: 20px;
    }
    .empty-state h2 {
      font-size: 20px; font-weight: 700; color: #1e293b; margin-bottom: 6px;
    }
    .empty-state p {
      font-size: 14px; color: #64748b; margin-bottom: 24px; line-height: 1.5;
    }
    .empty-state textarea {
      width: 100%; min-height: 160px; padding: 14px; font-size: 14px;
      font-family: 'Source Serif 4', Georgia, serif;
      border: 1px solid #e2e8f0; border-radius: 8px;
      resize: vertical; outline: none; line-height: 1.8; color: #334155;
    }
    .empty-state textarea:focus { border-color: #6366f1; }
    .empty-state textarea::placeholder { color: #94a3b8; font-family: 'DM Sans', sans-serif; font-size: 13px; }
    .empty-state-actions {
      display: flex; gap: 10px; justify-content: center; margin-top: 16px;
      flex-wrap: wrap;
    }
    .btn-load-text {
      padding: 8px 20px; font-size: 13px; font-weight: 600;
      color: #fff; border: none; border-radius: 8px; cursor: pointer;
      font-family: 'DM Sans', sans-serif;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      box-shadow: 0 1px 3px rgba(99, 102, 241, 0.3);
    }
    .btn-load-text:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-load-file {
      padding: 8px 20px; font-size: 13px; font-weight: 600;
      color: #6366f1; background: rgba(99, 102, 241, 0.08);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 8px; cursor: pointer;
      font-family: 'DM Sans', sans-serif;
    }
    .btn-sample {
      padding: 8px 20px; font-size: 13px; font-weight: 500;
      color: #64748b; background: transparent;
      border: 1px solid #e2e8f0; border-radius: 8px; cursor: pointer;
      font-family: 'DM Sans', sans-serif;
    }

    /* Revision controls row */
    .revision-bar {
      display: flex; align-items: center; gap: 6px;
      margin-bottom: 8px;
    }
    .revision-bar .spacer { flex: 1; }

    /* Global instructions bar */
    .global-bar {
      margin-bottom: 12px;
    }
    .global-bar textarea {
      width: 100%; padding: 10px 14px; font-size: 13px;
      font-family: 'DM Sans', system-ui, sans-serif;
      border: 1px solid #e2e8f0; border-radius: 8px;
      resize: none; outline: none; line-height: 1.5; color: #334155;
      background: #fff; min-height: 40px; max-height: 120px;
    }
    .global-bar textarea:focus { border-color: #6366f1; }
    .global-bar textarea::placeholder { color: #94a3b8; }

    /* Attachments */
    .attachments-bar {
      display: flex; align-items: center; gap: 8px;
      flex-wrap: wrap; margin-bottom: 8px;
    }
    .attach-btn {
      font-size: 12px; font-weight: 500; color: #6366f1;
      background: none; border: none; cursor: pointer;
      font-family: 'DM Sans', sans-serif; padding: 0;
    }
    .attach-btn:hover { text-decoration: underline; }
    .attach-chip {
      display: inline-flex; align-items: center; gap: 4px;
      padding: 3px 10px; font-size: 12px; font-weight: 500;
      background: rgba(99, 102, 241, 0.08);
      border: 1px solid rgba(99, 102, 241, 0.18);
      border-radius: 14px; color: #475569;
    }
    .attach-chip-remove {
      background: none; border: none; cursor: pointer;
      color: #94a3b8; font-size: 14px; padding: 0; line-height: 1;
    }
    .attach-chip-remove:hover { color: #dc2626; }

    /* Document column wrapper */
    .doc-column {
      flex: 1; min-width: 0;
      display: flex; flex-direction: column;
    }

    /* Save status indicator */
    .save-indicator {
      font-size: 12px; font-weight: 500; margin-left: 10px;
      display: inline-flex; align-items: center; gap: 4px;
    }
    .save-indicator.saving { color: #7c3aed; }
    .save-indicator.saved { color: #16a34a; }
    .save-indicator.unsaved { color: #d97706; }
    .save-indicator.error { color: #dc2626; }

    /* Editable document title */
    .header-title-input {
      font-size: 15px; font-weight: 600; color: #1e293b;
      border: 1px solid transparent; border-radius: 4px;
      padding: 2px 6px; background: transparent;
      font-family: 'DM Sans', sans-serif;
      outline: none; width: 220px;
      transition: border-color 0.15s, background 0.15s;
    }
    .header-title-input:hover { background: #f8fafc; border-color: #e2e8f0; }
    .header-title-input:focus { background: #fff; border-color: #6366f1; }

    /* Back button */
    .btn-back {
      background: none; border: none; cursor: pointer;
      color: #94a3b8; padding: 4px; border-radius: 6px;
      display: flex; align-items: center; justify-content: center;
      transition: color 0.15s, background 0.15s;
    }
    .btn-back:hover { color: #475569; background: #f1f5f9; }

    /* Document card grid */
    .doc-grid-container {
      max-width: 900px; margin: 40px auto 0; padding: 0 24px;
    }
    .doc-grid-container h3 {
      font-size: 14px; font-weight: 700; color: #1e293b; margin-bottom: 16px;
    }
    .doc-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(190px, 1fr));
      gap: 16px;
    }
    .doc-card {
      background: #fff; border: 1px solid #e8e5e0; border-radius: 10px;
      overflow: hidden; cursor: pointer; position: relative;
      transition: box-shadow 0.2s, transform 0.2s;
    }
    .doc-card:hover {
      box-shadow: 0 4px 16px rgba(0,0,0,0.08);
      transform: translateY(-2px);
    }
    .doc-card-new {
      background: #fff; border: 2px dashed #d4d4d8; border-radius: 10px;
      display: flex; flex-direction: column; align-items: center;
      justify-content: center; cursor: pointer; min-height: 180px;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    .doc-card-new:hover {
      border-color: #8b5cf6;
      box-shadow: 0 4px 16px rgba(99,102,241,0.1);
    }
    .doc-card-new-icon {
      width: 40px; height: 40px; border-radius: 50%;
      background: #f1f5f9; display: flex; align-items: center;
      justify-content: center; font-size: 24px; color: #94a3b8;
      margin-bottom: 8px; transition: background 0.2s, color 0.2s;
    }
    .doc-card-new:hover .doc-card-new-icon {
      background: rgba(99,102,241,0.1); color: #6366f1;
    }
    .doc-card-new-label {
      font-size: 13px; font-weight: 600; color: #94a3b8;
      transition: color 0.2s;
    }
    .doc-card-new:hover .doc-card-new-label { color: #6366f1; }
    .doc-card-preview {
      height: 110px; padding: 12px 14px; background: #f9fafb;
      overflow: hidden; font-family: 'Source Serif 4', Georgia, serif;
      font-size: 11px; line-height: 1.6; color: #64748b;
      border-bottom: 1px solid #f1f5f9;
    }
    .doc-card-info {
      padding: 10px 14px;
    }
    .doc-card-title {
      font-size: 13px; font-weight: 600; color: #1e293b;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .doc-card-time {
      font-size: 11px; color: #94a3b8; margin-top: 2px;
    }
    .doc-card-delete {
      position: absolute; top: 6px; right: 6px;
      background: #fff; border: 1px solid #e8e5e0; color: #94a3b8;
      cursor: pointer; font-size: 14px; width: 24px; height: 24px;
      border-radius: 6px; display: flex; align-items: center;
      justify-content: center; opacity: 0;
      transition: opacity 0.15s, color 0.15s, border-color 0.15s;
    }
    .doc-card:hover .doc-card-delete { opacity: 1; }
    .doc-card-delete:hover { color: #dc2626; border-color: rgba(220,38,38,0.3); }

    /* Mode toggle (segmented control) */
    .mode-toggle {
      display: inline-flex; border: 1px solid #e2e8f0; border-radius: 8px;
      overflow: hidden; margin-right: 4px;
    }
    .mode-toggle-btn {
      padding: 4px 10px; font-size: 12px; font-weight: 600;
      font-family: 'DM Sans', sans-serif;
      border: none; background: #fff; color: #64748b;
      cursor: pointer; display: inline-flex; align-items: center; gap: 4px;
      transition: background 0.15s, color 0.15s;
    }
    .mode-toggle-btn:not(:last-child) { border-right: 1px solid #e2e8f0; }
    .mode-toggle-btn:hover { background: #f8fafc; }
    .mode-toggle-btn.active {
      background: #6366f1; color: #fff;
    }
    .mode-toggle-btn.active:hover { background: #4f46e5; }

    /* Normal mode paragraph */
    .paragraph-normal { cursor: default; user-select: text; caret-color: transparent; }

    /* Pending changes in Normal mode */
    .change-pending-normal {
      border-left: 3px solid #22c55e; padding-left: 4px;
      background: rgba(34, 197, 94, 0.06); border-radius: 2px;
    }

    /* LaTeX section headings */
    .latex-section {
      display: block;
      font-size: 24px; font-weight: 700; color: #1e293b;
      margin: 8px 0 4px; line-height: 1.4;
      font-family: 'DM Sans', 'Segoe UI', system-ui, sans-serif;
    }
    .latex-subsection {
      display: block;
      font-size: 19px; font-weight: 600; color: #334155;
      margin: 6px 0 2px; line-height: 1.4;
      font-family: 'DM Sans', 'Segoe UI', system-ui, sans-serif;
    }

    /* LaTeX error */
    .latex-error {
      color: #dc2626; font-size: 12px; font-family: monospace;
      background: rgba(220, 38, 38, 0.06); padding: 1px 4px;
      border-radius: 3px;
    }
    /* Unrenderable LaTeX markup (e.g. \ref, \cite, \label) */
    .latex-markup {
      font-size: 12px; font-family: 'SFMono-Regular', 'Consolas', monospace;
      background: #eef0f4; color: #64748b; padding: 1px 5px;
      border-radius: 4px; white-space: nowrap;
    }

    /* Click-to-edit paragraph in Normal mode */
    .paragraph-editing {
      outline: 2px solid rgba(99, 102, 241, 0.3);
      outline-offset: 2px;
      border-radius: 4px;
      background: rgba(99, 102, 241, 0.02);
    }

    /* KaTeX display math spacing */
    .katex-display { margin: 12px 0; text-align: center; }
  </style>
</head>
<body>

<div id="app"></div>

<!-- Selection toolbar (lives outside #app so render() won't destroy it) -->
<div class="selection-toolbar" id="selection-toolbar">
  <button onclick="openCommentCard()" title="Add comment">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
      <line x1="12" y1="8" x2="12" y2="14"/>
      <line x1="9" y1="11" x2="15" y2="11"/>
    </svg>
  </button>
</div>

<!-- Comment card (lives outside #app so render() won't destroy it) -->
<div class="comment-card" id="comment-card" onmousedown="event.stopPropagation()">
  <textarea id="comment-input" placeholder="Add a comment or revision note..."></textarea>
  <div class="comment-card-actions">
    <button class="popover-cancel" onclick="closeCommentCard()">Cancel</button>
    <button class="popover-submit" onclick="submitComment()">Comment</button>
  </div>
</div>

<script>
// ── State ──────────────────────────────────────────────
const SAMPLE_DOC = [
  "The morning light filtered through the tall windows of the library, casting long golden rectangles across the oak reading tables. Dust motes drifted lazily in the beams, each one a tiny universe suspended in amber.",
  "Eleanor traced her finger along the cracked spine of the atlas, feeling each ridge like a mountain range in miniature. The book had been her grandfather's — one of the few things she'd kept after the estate sale.",
  "She turned to the map of the coastline, where faded blue ink marked harbors that no longer existed. Entire towns had been swallowed by the sea since this atlas was printed, their names now belonging only to the cartographer's careful hand.",
  "Outside, the rain began again — soft at first, then insistent, drumming against the skylight like impatient fingers. Eleanor closed the atlas and listened.",
];

let state = {
  paragraphs: [],
  model: "claude-sonnet-4-5-20250929",
  comments: [],       // { id, paraIndex, start, end, selectedText, comment, colorIdx }
  activeCommentId: null,
  pendingSelection: null,  // { paraIndex, start, end, selectedText }
  colorCounter: 0,
  showBanner: true,
  globalInstruction: "",
  attachments: [],    // { name, base64 }
  loading: false,
  toast: null,
  docId: null,
  docTitle: "Untitled",
  saveStatus: null,   // "saving" | "saved" | "unsaved" | "error" | null
  docList: null,      // cached document list for home view
  viewMode: "source", // "source" | "normal" — not persisted
  revisionScope: "focused", // "focused" | "section" | "subsection" | "full" — not persisted
  editingPara: null, // paragraph index being click-to-edited in Normal mode
};

const COLORS = [
  { bg: "rgba(251,191,36,0.25)", border: "#f59e0b" },
  { bg: "rgba(167,139,250,0.25)", border: "#8b5cf6" },
  { bg: "rgba(52,211,153,0.25)", border: "#10b981" },
  { bg: "rgba(251,113,133,0.25)", border: "#f43f5e" },
  { bg: "rgba(96,165,250,0.25)", border: "#3b82f6" },
];

let changeIdCounter = 0;

// ── Helpers ────────────────────────────────────────────
function getPlainText(segments) {
  return segments.map(s => s.type === "text" ? s.content : s.oldContent).join("");
}

function getPlainParagraphs() {
  return state.paragraphs.map(p =>
    p.segments.map(s => s.type === "text" ? s.content : (s.newContent || s.oldContent)).join("")
  );
}

function getFocusedIndices(commentedIndices, totalParas) {
  const included = new Set();
  for (const idx of commentedIndices) {
    if (idx > 0) included.add(idx - 1);
    included.add(idx);
    if (idx < totalParas - 1) included.add(idx + 1);
  }
  return included;
}

function getBlockStartsByRegex(plainParas, regex) {
  const starts = [];
  plainParas.forEach((text, idx) => {
    if (regex.test(text)) starts.push(idx);
  });
  return starts;
}

function getBlocksFromStarts(starts, totalParas) {
  if (starts.length === 0 || totalParas === 0) return [];
  const sorted = Array.from(new Set(starts)).sort((a, b) => a - b);
  const blocks = [];
  if (sorted[0] > 0) blocks.push({ start: 0, end: sorted[0] - 1 });
  for (let i = 0; i < sorted.length; i++) {
    const start = sorted[i];
    const next = i < sorted.length - 1 ? sorted[i + 1] : totalParas;
    blocks.push({ start, end: next - 1 });
  }
  return blocks;
}

function getSubsectionBlocks(plainParas, sectionBlocks, subsectionStarts) {
  if (subsectionStarts.length === 0 || plainParas.length === 0) return [];
  const sortedSubStarts = Array.from(new Set(subsectionStarts)).sort((a, b) => a - b);
  const parentRanges = sectionBlocks.length > 0 ? sectionBlocks : [{ start: 0, end: plainParas.length - 1 }];
  const blocks = [];

  for (const parent of parentRanges) {
    const subs = sortedSubStarts.filter(i => i >= parent.start && i <= parent.end);
    if (subs.length === 0) {
      blocks.push({ start: parent.start, end: parent.end });
      continue;
    }
    if (subs[0] > parent.start) blocks.push({ start: parent.start, end: subs[0] - 1 });
    for (let i = 0; i < subs.length; i++) {
      const start = subs[i];
      const nextStart = i < subs.length - 1 ? subs[i + 1] : (parent.end + 1);
      blocks.push({ start, end: nextStart - 1 });
    }
  }
  return blocks;
}

function getLatexScopeInfo(plainParas) {
  const sectionStarts = getBlockStartsByRegex(plainParas, /\\section\*?\s*\{/);
  const subsectionStarts = getBlockStartsByRegex(plainParas, /\\subsection\*?\s*\{/);
  const sectionBlocks = getBlocksFromStarts(sectionStarts, plainParas.length);
  const subsectionBlocks = getSubsectionBlocks(plainParas, sectionBlocks, subsectionStarts);
  const hasLatexMarkers = plainParas.some(p => /\\(?:begin|end|chapter|section|subsection|textbf|textit|emph|cite|ref)\b/.test(p));
  return {
    isLatexDoc: sectionStarts.length > 0 || subsectionStarts.length > 0 || hasLatexMarkers,
    sectionBlocks,
    subsectionBlocks,
  };
}

function normalizeRevisionScope(scope, scopeInfo) {
  if (scope === "section" && (!scopeInfo.isLatexDoc || scopeInfo.sectionBlocks.length === 0)) return "focused";
  if (scope === "subsection" && (!scopeInfo.isLatexDoc || scopeInfo.subsectionBlocks.length === 0)) return "focused";
  if (scope !== "focused" && scope !== "section" && scope !== "subsection" && scope !== "full") return "focused";
  return scope;
}

function expandIndicesByBlocks(commentedIndices, blocks, fallbackIndices) {
  const included = new Set();
  for (const idx of commentedIndices) {
    const block = blocks.find(b => idx >= b.start && idx <= b.end);
    if (!block) continue;
    for (let i = block.start; i <= block.end; i++) included.add(i);
  }
  if (included.size === 0) return new Set(fallbackIndices);
  return included;
}

function getPendingCount() {
  return state.paragraphs.reduce((n, p) =>
    n + p.segments.filter(s => s.type === "change" && s.status === "pending").length, 0);
}

function showToast(msg, isError) {
  state.toast = { msg, isError };
  render();
  setTimeout(() => { state.toast = null; render(); }, 3000);
}

function attachFile() {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = ".pdf";
  input.multiple = true;
  input.onchange = (e) => {
    Array.from(e.target.files).forEach(file => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result.split(",")[1];
        state.attachments.push({ name: file.name, base64 });
        scheduleSave();
        render();
      };
      reader.readAsDataURL(file);
    });
  };
  input.click();
}

function removeAttachment(index) {
  state.attachments.splice(index, 1);
  scheduleSave();
  render();
}

// ── Persistence helpers ────────────────────────────────
function getSaveableState() {
  return {
    paragraphs: state.paragraphs,
    comments: state.comments,
    globalInstruction: state.globalInstruction,
    attachments: state.attachments,
    model: state.model,
    colorCounter: state.colorCounter,
  };
}

let saveTimer = null;

function scheduleSave() {
  if (!state.docId) return;
  state.saveStatus = "unsaved";
  updateSaveIndicator();
  clearTimeout(saveTimer);
  saveTimer = setTimeout(performSave, 1500);
}

async function performSave() {
  if (!state.docId) return;
  state.saveStatus = "saving";
  updateSaveIndicator();
  try {
    const res = await fetch(`/api/documents/${state.docId}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ title: state.docTitle, content: getSaveableState() }),
    });
    if (!res.ok) throw new Error("Save failed");
    state.saveStatus = "saved";
  } catch {
    state.saveStatus = "error";
  }
  updateSaveIndicator();
}

function updateSaveIndicator() {
  const el = document.getElementById("save-indicator");
  if (!el) return;
  const labels = { saving: "Saving…", saved: "Saved", unsaved: "Unsaved", error: "Save failed" };
  if (!state.saveStatus) { el.textContent = ""; el.className = "save-indicator"; return; }
  el.textContent = labels[state.saveStatus] || "";
  el.className = "save-indicator " + state.saveStatus;
}

// ── URL routing ────────────────────────────────────────
function updateUrl(docId) {
  const url = new URL(window.location);
  if (docId) {
    url.searchParams.set("doc", docId);
  } else {
    url.searchParams.delete("doc");
  }
  history.replaceState(null, "", url);
}

// ── Document list ──────────────────────────────────────
async function fetchDocList() {
  try {
    const res = await fetch("/api/documents");
    state.docList = await res.json();
  } catch {
    state.docList = [];
  }
  render();
}

async function openDocument(id) {
  try {
    const res = await fetch(`/api/documents/${id}`);
    if (!res.ok) throw new Error("Not found");
    const doc = await res.json();
    const c = doc.content || {};
    state.paragraphs = c.paragraphs || [];
    state.comments = c.comments || [];
    state.globalInstruction = c.globalInstruction || "";
    state.attachments = c.attachments || [];
    state.model = c.model || "claude-sonnet-4-5-20250929";
    state.colorCounter = c.colorCounter || 0;
    state.docId = doc.id;
    state.docTitle = doc.title;
    state.activeCommentId = null;
    state.pendingSelection = null;
    state.saveStatus = "saved";
    state.showBanner = false;
    state.docList = null;
    // Restore changeIdCounter from loaded segments
    let maxId = 0;
    state.paragraphs.forEach(p => {
      p.segments.forEach(s => {
        if (s.type === "change" && s.id) {
          const num = parseInt(s.id.replace("ch", ""), 10);
          if (num > maxId) maxId = num;
        }
      });
    });
    changeIdCounter = maxId;
    updateUrl(doc.id);
    render();
  } catch {
    showToast("Could not open document", true);
  }
}

async function deleteDocument(id, event) {
  event.stopPropagation();
  if (!confirm("Delete this document?")) return;
  try {
    await fetch(`/api/documents/${id}`, { method: "DELETE" });
    if (state.docList) state.docList = state.docList.filter(d => d.id !== id);
    render();
  } catch {
    showToast("Could not delete document", true);
  }
}

function formatRelativeTime(dateStr) {
  const date = new Date(dateStr + "Z"); // SQLite datetime is UTC
  const now = new Date();
  const diffMs = now - date;
  const diffSec = Math.floor(diffMs / 1000);
  if (diffSec < 60) return "just now";
  const diffMin = Math.floor(diffSec / 60);
  if (diffMin < 60) return `${diffMin} min${diffMin !== 1 ? "s" : ""} ago`;
  const diffHr = Math.floor(diffMin / 60);
  if (diffHr < 24) return `${diffHr} hour${diffHr !== 1 ? "s" : ""} ago`;
  const diffDay = Math.floor(diffHr / 24);
  if (diffDay === 1) return "yesterday";
  if (diffDay < 30) return `${diffDay} days ago`;
  return date.toLocaleDateString();
}

// ── Document loading ───────────────────────────────────
async function loadText(text) {
  const content = text.trim();
  if (!content) return;
  const normalized = content.replace(/\r\n/g, '\n');
  let blocks;
  if (/\n\n/.test(normalized)) {
    blocks = normalized.split(/\n\n+/);
  } else {
    blocks = normalized.split(/\n/);
  }
  state.paragraphs = blocks.filter(b => b.trim().length > 0).map(b => ({
    segments: [{ type: "text", content: b }]
  }));
  if (state.paragraphs.length === 0) {
    state.paragraphs = [{ segments: [{ type: "text", content: "" }] }];
  }
  state.comments = [];
  state.activeCommentId = null;
  state.showBanner = true;
  state.docTitle = "Untitled";
  state.docList = null;
  // Create doc on server
  try {
    const res = await fetch("/api/documents", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ title: state.docTitle, content: getSaveableState() }),
    });
    const doc = await res.json();
    state.docId = doc.id;
    state.saveStatus = "saved";
    updateUrl(doc.id);
  } catch {
    state.saveStatus = "error";
  }
  render();
}

async function createBlankDocument() {
  state.paragraphs = [{ segments: [{ type: "text", content: "" }] }];
  state.comments = [];
  state.activeCommentId = null;
  state.showBanner = true;
  state.docTitle = "Untitled";
  state.docList = null;
  try {
    const res = await fetch("/api/documents", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ title: state.docTitle, content: getSaveableState() }),
    });
    const doc = await res.json();
    state.docId = doc.id;
    state.saveStatus = "saved";
    updateUrl(doc.id);
  } catch {
    state.saveStatus = "error";
  }
  render();
}

async function loadSampleDoc() {
  await loadText(SAMPLE_DOC.join("\n\n"));
}

function loadFile() {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = ".txt,.tex,.md,.latex,text/plain";
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => loadText(reader.result);
    reader.readAsText(file);
  };
  input.click();
}

async function newDocument() {
  // Flush any pending save
  if (saveTimer) { clearTimeout(saveTimer); await performSave(); }
  state.paragraphs = [];
  state.comments = [];
  state.activeCommentId = null;
  state.pendingSelection = null;
  state.docId = null;
  state.docTitle = "Untitled";
  state.saveStatus = null;
  state.globalInstruction = "";
  state.attachments = [];
  hideSelectionToolbar();
  state.showBanner = true;
  updateUrl(null);
  fetchDocList();
}

// ── Actions ────────────────────────────────────────────
function acceptChange(changeId) {
  state.paragraphs.forEach(p => {
    p.segments = p.segments.map(s => {
      if (s.type === "change" && s.id === changeId) {
        return { type: "text", content: s.newContent, flash: true };
      }
      return s;
    });
  });
  scheduleSave();
  render();
  setTimeout(() => {
    state.paragraphs.forEach(p => {
      p.segments = p.segments.map(s => {
        if (s.flash) { const { flash, ...rest } = s; return rest; }
        return s;
      });
    });
    render();
  }, 1200);
}

function rejectChange(changeId) {
  state.paragraphs.forEach(p => {
    p.segments = p.segments.map(s => {
      if (s.type === "change" && s.id === changeId)
        return { type: "text", content: s.oldContent };
      return s;
    });
  });
  scheduleSave();
  render();
}

function acceptAll() {
  state.paragraphs.forEach(p => {
    p.segments = p.segments.map(s => {
      if (s.type === "change" && s.status === "pending")
        return { type: "text", content: s.newContent, flash: true };
      return s;
    });
  });
  scheduleSave();
  render();
  setTimeout(() => {
    state.paragraphs.forEach(p => {
      p.segments = p.segments.map(s => {
        if (s.flash) { const { flash, ...rest } = s; return rest; }
        return s;
      });
    });
    render();
  }, 1200);
}

function rejectAll() {
  state.paragraphs.forEach(p => {
    p.segments = p.segments.map(s => {
      if (s.type === "change" && s.status === "pending")
        return { type: "text", content: s.oldContent };
      return s;
    });
  });
  scheduleSave();
  render();
}

function addComment(comment) {
  if (!state.pendingSelection || !comment.trim()) return;
  const p = state.pendingSelection;
  state.comments.push({
    id: Date.now(),
    paraIndex: p.paraIndex,
    start: p.start,
    end: p.end,
    selectedText: p.selectedText,
    comment: comment.trim(),
    colorIdx: state.colorCounter,
  });
  state.colorCounter++;
  state.activeCommentId = state.comments[state.comments.length - 1].id;
  state.pendingSelection = null;
  hideSelectionToolbar();
  window.getSelection()?.removeAllRanges();
  scheduleSave();
  render();
}

function deleteComment(id) {
  state.comments = state.comments.filter(c => c.id !== id);
  state.activeCommentId = null;
  scheduleSave();
  render();
}

async function requestRevision() {
  const hasComments = state.comments.length > 0;
  const hasGlobal = state.globalInstruction.trim().length > 0;
  if (!hasComments && !hasGlobal) return;

  const plainParas = getPlainParagraphs();
  const scopeInfo = getLatexScopeInfo(plainParas);
  const normalizedScope = normalizeRevisionScope(state.revisionScope, scopeInfo);
  if (normalizedScope !== state.revisionScope) {
    state.revisionScope = normalizedScope;
  }

  // Determine effective scope (auto-select full if no comments)
  const effectiveScope = (!hasComments && hasGlobal) ? "full" : normalizedScope;

  state.loading = true;
  render();

  try {
    const body = {
      comments: state.comments.map(c => ({
        paraIndex: c.paraIndex,
        selectedText: c.selectedText,
        comment: c.comment,
      })),
      model: state.model,
      scopeMode: effectiveScope,
    };

    if (effectiveScope !== "full" && hasComments) {
      const commentedIndices = new Set(
        state.comments
          .map(c => c.paraIndex)
          .filter(i => i >= 0 && i < plainParas.length)
      );
      const focusedIndices = getFocusedIndices(commentedIndices, plainParas.length);
      let includedIndices = focusedIndices;

      if (effectiveScope === "section") {
        includedIndices = expandIndicesByBlocks(commentedIndices, scopeInfo.sectionBlocks, focusedIndices);
      } else if (effectiveScope === "subsection") {
        includedIndices = expandIndicesByBlocks(commentedIndices, scopeInfo.subsectionBlocks, focusedIndices);
      }

      const paragraphMap = Array.from(includedIndices).sort((a, b) => a - b)
        .map(i => ({ index: i, text: plainParas[i] }));
      body.focusedMode = true;
      body.paragraphMap = paragraphMap;
    } else {
      body.focusedMode = false;
      body.paragraphs = plainParas;
    }

    if (hasGlobal) body.globalInstruction = state.globalInstruction.trim();
    if (state.attachments.length > 0) body.attachments = state.attachments;

    const res = await fetch("/api/revise", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });

    const data = await res.json();

    if (data.error) {
      showToast(data.error, true);
      state.loading = false;
      render();
      return;
    }

    // Apply changes as tracked revisions
    let appliedCount = 0;
    for (const change of data.changes) {
      const para = state.paragraphs[change.paraIndex];
      if (!para) { console.warn("Revision skipped: no paragraph at index", change.paraIndex); continue; }

      // Find the segment and position containing oldText
      const newSegments = [];
      let applied = false;

      for (const seg of para.segments) {
        if (applied || seg.type !== "text") {
          newSegments.push(seg);
          continue;
        }

        const idx = seg.content.indexOf(change.oldText);
        if (idx === -1) {
          newSegments.push(seg);
          continue;
        }

        // Split: before + change + after
        if (idx > 0) {
          newSegments.push({ type: "text", content: seg.content.slice(0, idx) });
        }
        newSegments.push({
          type: "change",
          id: "ch" + (++changeIdCounter),
          oldContent: change.oldText,
          newContent: change.newText,
          status: "pending",
        });
        const afterIdx = idx + change.oldText.length;
        if (afterIdx < seg.content.length) {
          newSegments.push({ type: "text", content: seg.content.slice(afterIdx) });
        }
        applied = true;
      }

      if (applied) {
        para.segments = newSegments;
        appliedCount++;
      } else {
        console.warn("Revision skipped: oldText not found in paragraph", change.paraIndex, JSON.stringify(change.oldText));
      }
    }

    // Clear comments and global instruction that were addressed
    state.comments = [];
    state.activeCommentId = null;
    state.globalInstruction = "";

    if (appliedCount === 0) {
      showToast("Claude couldn't find matching text to revise", true);
    } else {
      showToast(`${appliedCount} revision${appliedCount > 1 ? "s" : ""} applied`);
    }
    scheduleSave();
  } catch (err) {
    showToast("Network error — is the server running?", true);
  }

  state.loading = false;
  render();
}

// ── Input handler (direct text editing) ────────────────
function handleInput(e) {
  let node = e.target;
  while (node && !(node.dataset && node.dataset.para !== undefined)) {
    node = node.parentElement;
  }
  // With document-level contenteditable, e.target is the document div.
  // Fall back to finding the paragraph from cursor position.
  if (!node) {
    const sel = window.getSelection();
    if (sel && sel.rangeCount) {
      node = sel.anchorNode;
      while (node && !(node.dataset && node.dataset.para !== undefined)) {
        node = node.parentElement;
      }
    }
  }
  if (!node) return;

  const pi = parseInt(node.dataset.para);
  // In normal mode, only handle input for the editing paragraph
  if (state.viewMode === "normal" && pi !== state.editingPara) return;
  const para = state.paragraphs[pi];
  if (!para) return;

  const newText = node.innerText;
  para.segments = [{ type: "text", content: newText }];

  scheduleSave();

  // Remove comments on this paragraph (offsets are now invalid)
  const hadComments = state.comments.some(c => c.paraIndex === pi);
  if (hadComments) {
    state.comments = state.comments.filter(c => c.paraIndex !== pi);
    if (state.activeCommentId && !state.comments.find(c => c.id === state.activeCommentId)) {
      state.activeCommentId = null;
    }
    // Lightweight DOM update for header status
    const statusEl = document.querySelector(".header-status");
    if (statusEl) {
      const pendingCount = getPendingCount();
      let txt = "";
      if (state.comments.length > 0) txt += `${state.comments.length} comment${state.comments.length !== 1 ? "s" : ""}`;
      if (state.comments.length > 0 && pendingCount > 0) txt += " · ";
      if (pendingCount > 0) txt += `${pendingCount} change${pendingCount !== 1 ? "s" : ""}`;
      if (state.comments.length === 0 && pendingCount === 0) txt = "No changes";
      statusEl.textContent = txt;
    }
  }
}

function getParaNodeFromNode(node) {
  if (!node) return null;
  if (node.nodeType === Node.TEXT_NODE) node = node.parentElement;
  while (node && !(node.dataset && node.dataset.para !== undefined)) {
    node = node.parentElement;
  }
  return node || null;
}

function getSelectionParaNode(sel) {
  if (!sel || !sel.rangeCount) return null;
  let paraNode = getParaNodeFromNode(sel.anchorNode);
  if (paraNode) return paraNode;

  const range = sel.getRangeAt(0);
  paraNode = getParaNodeFromNode(range.startContainer);
  if (paraNode) return paraNode;

  const container = range.startContainer;
  if (container && container.nodeType === Node.ELEMENT_NODE) {
    const children = container.childNodes;
    paraNode = getParaNodeFromNode(children[range.startOffset] || null);
    if (paraNode) return paraNode;
    paraNode = getParaNodeFromNode(children[range.startOffset - 1] || null);
    if (paraNode) return paraNode;
  }
  return null;
}

function insertPlainTextAtSelection(text) {
  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) return false;
  const range = sel.getRangeAt(0);
  range.deleteContents();
  const textNode = document.createTextNode(text);
  range.insertNode(textNode);
  range.setStart(textNode, textNode.length);
  range.collapse(true);
  sel.removeAllRanges();
  sel.addRange(range);
  return true;
}

// ── Paste handler (multi-paragraph) ────────────────────
function handlePaste(e) {
  let blocks;
  const clipboard = e.clipboardData || window.clipboardData;
  if (!clipboard) return;

  // Try HTML first (rich text from Word, web pages, etc.)
  const html = clipboard.getData('text/html');
  if (html) {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    const blockEls = doc.querySelectorAll('p, div, li, h1, h2, h3, h4, h5, h6');
    if (blockEls.length > 1) {
      blocks = Array.from(blockEls).map(el => el.textContent.trim()).filter(t => t.length > 0);
    }
  }

  // Fall back to plain text
  if (!blocks || blocks.length <= 1) {
    const text = clipboard.getData('text/plain');
    if (!text) return;
    const normalized = text.replace(/\r\n/g, '\n');
    if (/\n\n/.test(normalized)) {
      blocks = normalized.split(/\n\n+/);
    } else {
      blocks = normalized.split(/\n/);
    }
    blocks = blocks.filter(b => b.trim().length > 0);
  }

  if (!blocks || blocks.length <= 1) {
    // Single-block paste
    const sel = window.getSelection();
    if (!sel || !sel.rangeCount) return;
    const paraNode = getSelectionParaNode(sel);
    if (!paraNode) return;
    const pi = parseInt(paraNode.dataset.para);
    if (state.viewMode === "normal" && pi !== state.editingPara) return;
    const text = (blocks && blocks[0]) || clipboard.getData('text/plain');
    if (!text) return;
    e.preventDefault();
    if (!insertPlainTextAtSelection(text)) return;
    paraNode.dispatchEvent(new Event("input", { bubbles: true }));
    return;
  }

  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) return;
  const paraNode = getSelectionParaNode(sel);
  if (!paraNode) return;
  const pi = parseInt(paraNode.dataset.para);
  const para = state.paragraphs[pi];
  if (!para) return;

  e.preventDefault();

  const fullText = getPlainText(para.segments);
  const cursorOffset = getCursorOffset(paraNode);

  // Handle selected text replacement
  const range = sel.getRangeAt(0);
  let selEnd = cursorOffset;
  if (!range.collapsed) {
    const preEndRange = document.createRange();
    preEndRange.setStart(paraNode, 0);
    preEndRange.setEnd(range.endContainer, range.endOffset);
    const endDiv = document.createElement('div');
    endDiv.style.whiteSpace = 'pre-wrap';
    endDiv.appendChild(preEndRange.cloneContents());
    selEnd = endDiv.innerText.length;
  }

  const before = fullText.slice(0, cursorOffset);
  const after = fullText.slice(selEnd);

  // First block: append to text before cursor
  para.segments = [{ type: "text", content: before + blocks[0] }];

  // Middle + last blocks become new paragraphs (last gets "after" text)
  const newParas = [];
  for (let i = 1; i < blocks.length - 1; i++) {
    newParas.push({ segments: [{ type: "text", content: blocks[i] }] });
  }
  newParas.push({ segments: [{ type: "text", content: blocks[blocks.length - 1] + after }] });
  state.paragraphs.splice(pi + 1, 0, ...newParas);

  // Adjust comments
  const insertedCount = newParas.length;
  state.comments = state.comments.filter(c => {
    if (c.paraIndex !== pi) return true;
    if (c.start < cursorOffset && c.end > cursorOffset) return false;
    if (c.start >= cursorOffset && c.end <= selEnd) return false;
    if (c.start < selEnd && c.end > cursorOffset) return false;
    return true;
  });
  state.comments.forEach(c => {
    if (c.paraIndex === pi && c.start >= selEnd) {
      c.paraIndex = pi + insertedCount;
      c.start = c.start - selEnd + blocks[blocks.length - 1].length;
      c.end = c.end - selEnd + blocks[blocks.length - 1].length;
    } else if (c.paraIndex > pi) {
      c.paraIndex += insertedCount;
    }
  });

  if (state.viewMode === "normal") state.editingPara = pi + insertedCount;
  scheduleSave();
  render();

  const cursorTarget = pi + insertedCount;
  const cursorPos = blocks[blocks.length - 1].length;
  requestAnimationFrame(() => {
    const targetNode = document.querySelector(`.paragraph[data-para="${cursorTarget}"]`);
    if (targetNode) {
      const docDiv = targetNode.closest('.document');
      if (docDiv) docDiv.focus();
      placeCursorAtOffset(targetNode, cursorPos);
    }
  });
}

// ── Copy handler (clean multi-paragraph text) ──────────
function handleCopy(e) {
  const sel = window.getSelection();
  if (!sel || !sel.rangeCount || sel.isCollapsed) return;

  let startNode = sel.getRangeAt(0).startContainer;
  let endNode = sel.getRangeAt(0).endContainer;
  while (startNode && !(startNode.dataset && startNode.dataset.para !== undefined)) startNode = startNode.parentElement;
  while (endNode && !(endNode.dataset && endNode.dataset.para !== undefined)) endNode = endNode.parentElement;
  if (!startNode || !endNode) return;

  const startPi = parseInt(startNode.dataset.para);
  const endPi = parseInt(endNode.dataset.para);

  // Single paragraph — let browser default handle it
  if (startPi === endPi) return;

  // Multi-paragraph: build clean text from state
  e.preventDefault();
  const parts = [];
  for (let i = startPi; i <= endPi; i++) {
    const para = state.paragraphs[i];
    if (!para) continue;
    parts.push(getPlainText(para.segments));
  }
  e.clipboardData.setData('text/plain', parts.join('\n\n'));
}

// ── Arrow key navigation + paragraph merging ───────────
function handleKeyDown(e) {
  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) return;

  let paraNode = sel.anchorNode;
  while (paraNode && !(paraNode.dataset && paraNode.dataset.para !== undefined)) {
    paraNode = paraNode.parentElement;
  }
  if (!paraNode) return;

  const pi = parseInt(paraNode.dataset.para);

  // In normal mode, only handle keys for the editing paragraph
  if (state.viewMode === "normal" && pi !== state.editingPara) return;

  // Shift+Enter → insert a line break within the paragraph
  if (e.key === "Enter" && e.shiftKey) {
    e.preventDefault();
    document.execCommand("insertLineBreak");
    return;
  }

  // Enter → split paragraph at cursor
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    const para = state.paragraphs[pi];
    if (!para) return;

    const fullText = getPlainText(para.segments);
    const cursorOffset = getCursorOffset(paraNode);

    const before = fullText.slice(0, cursorOffset);
    const after = fullText.slice(cursorOffset);

    // Update current paragraph to text before cursor
    para.segments = [{ type: "text", content: before }];

    // Insert new paragraph with text after cursor
    state.paragraphs.splice(pi + 1, 0, {
      segments: [{ type: "text", content: after }]
    });

    // Adjust comments
    const splitOffset = cursorOffset;
    state.comments = state.comments.filter(c => {
      if (c.paraIndex !== pi) return true;
      // Remove comments that span the split
      return !(c.start < splitOffset && c.end > splitOffset);
    });
    state.comments.forEach(c => {
      if (c.paraIndex === pi && c.start >= splitOffset) {
        // Move to new paragraph, adjust offsets
        c.paraIndex = pi + 1;
        c.start -= splitOffset;
        c.end -= splitOffset;
      } else if (c.paraIndex > pi) {
        c.paraIndex++;
      }
    });

    // In Normal mode, move editing to the new paragraph
    if (state.viewMode === "normal") state.editingPara = pi + 1;

    scheduleSave();
    render();

    // Place cursor at start of new paragraph
    requestAnimationFrame(() => {
      const newParaNode = document.querySelector(`.paragraph[data-para="${pi + 1}"]`);
      if (newParaNode) {
        newParaNode.focus();
        placeCursorAtOffset(newParaNode, 0);
      }
    });
    return;
  }

  // Backspace at start of paragraph → merge with previous
  if (e.key === "Backspace" && pi > 0) {
    const range = sel.getRangeAt(0);
    if (range.collapsed && isCursorAtStart(paraNode)) {
      e.preventDefault();
      const prevPara = state.paragraphs[pi - 1];
      const curPara = state.paragraphs[pi];
      if (!prevPara || !curPara) return;

      const prevText = getPlainText(prevPara.segments);
      const curText = getPlainText(curPara.segments);
      const joinOffset = prevText.length;

      // Merge into previous paragraph
      prevPara.segments = [{ type: "text", content: prevText + curText }];
      state.paragraphs.splice(pi, 1);

      // Fix comment indices
      state.comments = state.comments.filter(c => c.paraIndex !== pi);
      state.comments.forEach(c => {
        if (c.paraIndex === pi - 1) return; // already on prev, keep as-is
        if (c.paraIndex > pi) c.paraIndex--;
      });

      render();

      // Place cursor at the join point
      const newParaNode = document.querySelector(`.paragraph[data-para="${pi - 1}"]`);
      if (newParaNode) {
        newParaNode.focus();
        placeCursorAtOffset(newParaNode, joinOffset);
      }
      return;
    }
  }

  // Delete at end of paragraph → merge with next
  if (e.key === "Delete" && pi < state.paragraphs.length - 1) {
    const range = sel.getRangeAt(0);
    if (range.collapsed && isCursorAtEnd(paraNode)) {
      e.preventDefault();
      const curPara = state.paragraphs[pi];
      const nextPara = state.paragraphs[pi + 1];
      if (!curPara || !nextPara) return;

      const curText = getPlainText(curPara.segments);
      const nextText = getPlainText(nextPara.segments);
      const joinOffset = curText.length;

      curPara.segments = [{ type: "text", content: curText + nextText }];
      state.paragraphs.splice(pi + 1, 1);

      state.comments = state.comments.filter(c => c.paraIndex !== pi + 1);
      state.comments.forEach(c => {
        if (c.paraIndex > pi + 1) c.paraIndex--;
      });

      render();

      const newParaNode = document.querySelector(`.paragraph[data-para="${pi}"]`);
      if (newParaNode) {
        newParaNode.focus();
        placeCursorAtOffset(newParaNode, joinOffset);
      }
      return;
    }
  }

  // Arrow navigation across paragraphs
  if (e.key !== "ArrowDown" && e.key !== "ArrowUp") return;

  const startContainer = sel.getRangeAt(0).startContainer;
  const startOffset = sel.getRangeAt(0).startOffset;

  requestAnimationFrame(() => {
    const newSel = window.getSelection();
    if (!newSel || !newSel.rangeCount) return;
    const newRange = newSel.getRangeAt(0);

    if (newRange.startContainer === startContainer && newRange.startOffset === startOffset) {
      const targetPi = e.key === "ArrowDown" ? pi + 1 : pi - 1;
      if (targetPi < 0 || targetPi >= state.paragraphs.length) return;

      if (state.viewMode === "normal") {
        // Switch editing to the target paragraph
        state.editingPara = targetPi;
        render();
        // Position cursor at end for ArrowUp, start for ArrowDown
        if (e.key === "ArrowUp") {
          const node = document.querySelector(`.paragraph-editing`);
          if (node) {
            const r = document.createRange();
            r.selectNodeContents(node);
            r.collapse(false);
            const s = window.getSelection();
            s.removeAllRanges();
            s.addRange(r);
          }
        }
      } else {
        const allParas = Array.from(document.querySelectorAll('.paragraph[data-para]'));
        const targetPara = allParas.find(p => parseInt(p.dataset.para) === targetPi);
        if (!targetPara) return;

        const r = document.createRange();
        if (e.key === "ArrowDown") {
          r.setStart(targetPara, 0);
          r.collapse(true);
        } else {
          r.selectNodeContents(targetPara);
          r.collapse(false);
        }
        newSel.removeAllRanges();
        newSel.addRange(r);
      }
    }
  });
}

function getCursorOffset(paraNode) {
  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) return 0;
  const range = sel.getRangeAt(0);
  const preRange = document.createRange();
  preRange.setStart(paraNode, 0);
  preRange.setEnd(range.startContainer, range.startOffset);
  const fragment = preRange.cloneContents();
  const div = document.createElement('div');
  div.style.whiteSpace = 'pre-wrap';
  div.appendChild(fragment);
  return div.innerText.length;
}

function isCursorAtStart(paraNode) {
  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) return false;
  const range = sel.getRangeAt(0);
  const testRange = document.createRange();
  testRange.setStart(paraNode, 0);
  testRange.setEnd(range.startContainer, range.startOffset);
  return testRange.toString().length === 0;
}

function isCursorAtEnd(paraNode) {
  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) return false;
  const range = sel.getRangeAt(0);
  const testRange = document.createRange();
  testRange.setStart(range.endContainer, range.endOffset);
  testRange.setEnd(paraNode, paraNode.childNodes.length);
  return testRange.toString().length === 0;
}

function placeCursorAtOffset(node, charOffset) {
  const sel = window.getSelection();
  const range = document.createRange();
  const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT);
  let remaining = charOffset;
  while (walker.nextNode()) {
    const textNode = walker.currentNode;
    if (remaining <= textNode.length) {
      range.setStart(textNode, remaining);
      range.collapse(true);
      sel.removeAllRanges();
      sel.addRange(range);
      return;
    }
    remaining -= textNode.length;
  }
  // Past the end — place at end
  range.selectNodeContents(node);
  range.collapse(false);
  sel.removeAllRanges();
  sel.addRange(range);
}

// ── Selection handler ──────────────────────────────────
function handleMouseUp(e) {
  // In Normal mode, allow selection even outside the editing paragraph
  // Don't interfere with toolbar/card clicks
  const toolbar = document.getElementById("selection-toolbar");
  const card = document.getElementById("comment-card");
  if (toolbar.contains(e.target) || card.contains(e.target)) return;

  // Small delay to let selection finalize
  setTimeout(() => {
    const sel = window.getSelection();
    if (!sel || sel.isCollapsed || !sel.rangeCount) {
      // Only hide if click was outside the toolbar/card
      if (!card.classList.contains("visible")) {
        hideSelectionToolbar();
      }
      return;
    }

    const selectedText = sel.toString().trim();
    if (!selectedText || selectedText.length < 2) return;

    // Find paragraph
    let node = sel.getRangeAt(0).startContainer;
    while (node && !(node.dataset && node.dataset.para !== undefined)) {
      node = node.parentElement;
    }
    if (!node) return;

    const paraIndex = parseInt(node.dataset.para);
    const para = state.paragraphs[paraIndex];
    if (!para) return;

    const plainText = getPlainText(para.segments);
    const idx = plainText.indexOf(selectedText);
    if (idx === -1) return;

    // Store selection info without calling render()
    state.pendingSelection = {
      paraIndex,
      start: idx,
      end: idx + selectedText.length,
      selectedText,
    };

    // Position toolbar to the right of the document
    const docEl = document.querySelector(".document");
    const range = sel.getRangeAt(0);
    const rangeRect = range.getBoundingClientRect();
    if (docEl) {
      const docRect = docEl.getBoundingClientRect();
      showSelectionToolbar(docRect.right + 12, rangeRect.top + rangeRect.height / 2 - 18);
    }
  }, 10);
}

// ── Toolbar / Comment Card functions ───────────────────
function showSelectionToolbar(x, y) {
  const toolbar = document.getElementById("selection-toolbar");
  toolbar.style.left = x + "px";
  toolbar.style.top = y + "px";
  toolbar.classList.add("visible");
}

function hideSelectionToolbar() {
  const toolbar = document.getElementById("selection-toolbar");
  const card = document.getElementById("comment-card");
  toolbar.classList.remove("visible");
  card.classList.remove("visible");
  clearPendingHighlight();
  state.pendingSelection = null;
}

function applyPendingHighlight() {
  clearPendingHighlight();
  if (!CSS.highlights || !state.pendingSelection) return;
  const ps = state.pendingSelection;
  const paraNode = document.querySelector(`.paragraph[data-para="${ps.paraIndex}"]`);
  if (!paraNode) return;

  const walker = document.createTreeWalker(paraNode, NodeFilter.SHOW_TEXT);
  let charCount = 0;
  const ranges = [];
  while (walker.nextNode()) {
    const node = walker.currentNode;
    const nodeStart = charCount;
    const nodeEnd = charCount + node.length;
    charCount = nodeEnd;
    const overlapStart = Math.max(ps.start, nodeStart);
    const overlapEnd = Math.min(ps.end, nodeEnd);
    if (overlapStart >= overlapEnd) continue;
    const r = new Range();
    r.setStart(node, overlapStart - nodeStart);
    r.setEnd(node, overlapEnd - nodeStart);
    ranges.push(r);
  }
  if (ranges.length > 0) {
    CSS.highlights.set("pending-comment", new Highlight(...ranges));
  }
}

function clearPendingHighlight() {
  if (CSS.highlights) CSS.highlights.delete("pending-comment");
}

function openCommentCard() {
  const toolbar = document.getElementById("selection-toolbar");
  const card = document.getElementById("comment-card");
  const tRect = toolbar.getBoundingClientRect();
  card.style.left = tRect.left + "px";
  card.style.top = (tRect.bottom + 6) + "px";
  card.classList.add("visible");
  applyPendingHighlight();
  const textarea = document.getElementById("comment-input");
  textarea.value = "";
  textarea.focus();
}

function closeCommentCard() {
  const card = document.getElementById("comment-card");
  card.classList.remove("visible");
  hideSelectionToolbar();
  window.getSelection()?.removeAllRanges();
}

function submitComment() {
  const textarea = document.getElementById("comment-input");
  addComment(textarea.value);
}

// ── Render ─────────────────────────────────────────────
function render() {
  const app = document.getElementById("app");
  const pendingCount = getPendingCount();

  let html = "";

  // Header
  html += `<div class="header">
    <div class="header-left">`;
  if (state.docId) {
    html += `<button class="btn-back" onclick="newDocument()" title="All documents">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M19 12H5"/><polyline points="12 19 5 12 12 5"/>
      </svg>
    </button>`;
  }
  html += `<div class="logo">C</div>`;
  if (state.docId) {
    html += `<input class="header-title-input" id="doc-title-input" value="${esc(state.docTitle)}"
      oninput="state.docTitle=this.value;scheduleSave()"
      onblur="scheduleSave()"
      spellcheck="false">`;
    const saveLabels = { saving: "Saving…", saved: "Saved", unsaved: "Unsaved", error: "Save failed" };
    html += `<span class="save-indicator ${state.saveStatus || ''}" id="save-indicator">${saveLabels[state.saveStatus] || ''}</span>`;
  } else {
    html += `<span class="header-title">Rick's Docs</span>`;
  }
  html += `<span class="header-status">`;
  if (state.comments.length > 0) html += `${state.comments.length} comment${state.comments.length !== 1 ? "s" : ""}`;
  if (state.comments.length > 0 && pendingCount > 0) html += " · ";
  if (pendingCount > 0) html += `${pendingCount} change${pendingCount !== 1 ? "s" : ""}`;
  if (state.comments.length === 0 && pendingCount === 0) html += "No changes";
  html += `</span></div><div class="header-actions">`;
  if (state.paragraphs.length > 0) {
    // Mode toggle
    html += `<div class="mode-toggle">
      <button class="mode-toggle-btn${state.viewMode === 'source' ? ' active' : ''}" onclick="state.viewMode='source';state.editingPara=null;latexCache.clear();render()" title="Source mode (Cmd+Shift+M)">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>
        Source
      </button>
      <button class="mode-toggle-btn${state.viewMode === 'normal' ? ' active' : ''}" onclick="state.viewMode='normal';state.editingPara=null;latexCache.clear();render()" title="Normal mode (Cmd+Shift+M)">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
        Normal
      </button>
    </div>`;
    html += `<button class="btn btn-new" onclick="loadFile()">Load File</button>`;
  }
  if (pendingCount > 0) {
    const nm = state.viewMode === "normal";
    html += `<button class="btn btn-reject" onclick="rejectAll()" ${nm ? 'disabled' : ''}>Reject All</button>`;
    html += `<button class="btn btn-accept" onclick="acceptAll()" ${nm ? 'disabled' : ''}>Accept All</button>`;
  }
  html += `</div></div>`;


  // Home page — card grid + start fresh
  if (state.paragraphs.length === 0) {
    html += `<div class="doc-grid-container">
      <h3>Recent documents</h3>
      <div class="doc-grid">
        <div class="doc-card-new" onclick="createBlankDocument()">
          <div class="doc-card-new-icon">+</div>
          <div class="doc-card-new-label">New document</div>
        </div>
        <div class="doc-card-new" onclick="loadSampleDoc()">
          <div class="doc-card-new-icon">+</div>
          <div class="doc-card-new-label">Sample document</div>
        </div>`;
    if (state.docList && state.docList.length > 0) {
      state.docList.forEach(d => {
        html += `<div class="doc-card" onclick="openDocument(${d.id})">
          <div class="doc-card-preview">${esc(d.preview || '')}</div>
          <div class="doc-card-info">
            <div class="doc-card-title">${esc(d.title)}</div>
            <div class="doc-card-time">${formatRelativeTime(d.updated_at)}</div>
          </div>
          <button class="doc-card-delete" onclick="deleteDocument(${d.id}, event)" title="Delete">&times;</button>
        </div>`;
      });
    }
    html += `</div></div>`;
  }

  if (state.paragraphs.length > 0) {
  // Layout
  html += `<div class="layout">`;

  // Document column (global bar + document)
  html += `<div class="doc-column">`;

  // Attachments
  html += `<div class="attachments-bar">`;
  html += `<button class="attach-btn" onclick="attachFile()">+ Attach PDF</button>`;
  state.attachments.forEach((a, i) => {
    html += `<span class="attach-chip">
      <span>${esc(a.name)}</span>
      <button class="attach-chip-remove" onclick="removeAttachment(${i})">×</button>
    </span>`;
  });
  html += `</div>`;

  // Global instructions
  html += `<div class="global-bar">
    <textarea id="global-input" placeholder="Describe a change to apply across the entire document..."
      oninput="state.globalInstruction=this.value;scheduleSave();var b=document.getElementById('btn-revise');if(b)b.disabled=!this.value.trim()&&state.comments.length===0">${esc(state.globalInstruction)}</textarea>
  </div>`;

  // Revision controls row (model, scope, button)
  {
    const reviseDisabled = state.comments.length === 0 && !state.globalInstruction.trim();
    const hasComments = state.comments.length > 0;
    const hasGlobal = state.globalInstruction.trim().length > 0;
    const plainParasForScope = getPlainParagraphs();
    const scopeInfo = getLatexScopeInfo(plainParasForScope);
    const normalizedScope = normalizeRevisionScope(state.revisionScope, scopeInfo);
    if (normalizedScope !== state.revisionScope) state.revisionScope = normalizedScope;
    const sectionScopeEnabled = scopeInfo.isLatexDoc && scopeInfo.sectionBlocks.length > 0;
    const subsectionScopeEnabled = scopeInfo.isLatexDoc && scopeInfo.subsectionBlocks.length > 0;
    const forceFull = !hasComments && hasGlobal;
    const effectiveScope = forceFull ? "full" : normalizedScope;
    html += `<div class="revision-bar">
      <select class="model-select" onchange="state.model=this.value;render()">
        <option value="claude-sonnet-4-5-20250929"${state.model === "claude-sonnet-4-5-20250929" ? " selected" : ""}>Sonnet 4.5</option>
        <option value="claude-opus-4-6"${state.model === "claude-opus-4-6" ? " selected" : ""}>Opus 4.6</option>
      </select>
      <select class="model-select" id="scope-select" onchange="state.revisionScope=this.value" ${forceFull ? 'disabled' : ''}>
        <option value="focused"${effectiveScope === "focused" ? " selected" : ""}>Focused</option>
        <option value="section"${effectiveScope === "section" ? " selected" : ""}${sectionScopeEnabled ? "" : " disabled"}>Section</option>
        <option value="subsection"${effectiveScope === "subsection" ? " selected" : ""}${subsectionScopeEnabled ? "" : " disabled"}>Subsection</option>
        <option value="full"${effectiveScope === "full" ? " selected" : ""}>Full Doc</option>
      </select>
      <span class="spacer"></span>
      <button class="btn btn-revise" id="btn-revise" onclick="requestRevision()" ${reviseDisabled ? 'disabled' : ''}>⟳ Request Revision</button>
    </div>`;
  }

  // Document
  const isNormal = state.viewMode === "normal";
  const docCE = state.paragraphs.length > 0 ? ' contenteditable="true"' : '';
  html += `<div class="document"${docCE}>`;
  state.paragraphs.forEach((para, pi) => {
    if (isNormal) {
      const hasPendingChanges = para.segments.some(s => s.type === "change" && s.status === "pending");
      const isEditing = pi === state.editingPara;

      if (isEditing && !hasPendingChanges) {
        // ── Normal mode, editing paragraph: render as Source-style ──
        html += `<p class="paragraph paragraph-editing" data-para="${pi}">`;
        para.segments.forEach((seg, si) => {
          if (seg.type === "change" && seg.status === "pending") {
            html += `<span class="change-old">${esc(seg.oldContent)}</span>`;
            html += `<span class="change-arrow"> → </span>`;
            html += `<span class="change-new">${esc(seg.newContent)}</span>`;
            html += `<button class="change-btn change-btn-accept" onclick="event.stopPropagation();acceptChange('${seg.id}')">✓</button>`;
            html += `<button class="change-btn change-btn-reject" onclick="event.stopPropagation();rejectChange('${seg.id}')">✕</button>`;
          } else if (seg.flash) {
            html += `<span class="change-flash">${esc(seg.content)}</span>`;
          } else {
            const content = seg.content;
            const paraComments = state.comments.filter(c => c.paraIndex === pi);
            if (paraComments.length === 0) {
              html += esc(content);
            } else {
              let offset = 0;
              for (let j = 0; j < si; j++) {
                const s = para.segments[j];
                offset += s.type === "text" ? s.content.length : (s.oldContent || s.content || "").length;
              }
              const segStart = offset;
              const segEnd = segStart + content.length;
              const overlapping = paraComments
                .filter(c => c.start < segEnd && c.end > segStart)
                .sort((a, b) => a.start - b.start);
              if (overlapping.length === 0) {
                html += esc(content);
              } else {
                let cursor = 0;
                for (const c of overlapping) {
                  const relStart = Math.max(0, c.start - segStart);
                  const relEnd = Math.min(content.length, c.end - segStart);
                  if (relStart > cursor) html += esc(content.slice(cursor, relStart));
                  const color = COLORS[c.colorIdx % COLORS.length];
                  const isActive = state.activeCommentId === c.id;
                  html += `<span class="highlight${isActive ? ' active' : ''}" data-comment-id="${c.id}"
                    style="background:${color.bg};border-bottom:2px solid ${color.border};${isActive ? 'outline:2px solid ' + color.border + ';outline-offset:1px;' : ''}"
                    onclick="event.stopPropagation();state.activeCommentId=${state.activeCommentId === c.id ? 'null' : c.id};render()"
                  >${esc(content.slice(relStart, relEnd))}</span>`;
                  cursor = relEnd;
                }
                if (cursor < content.length) html += esc(content.slice(cursor));
              }
            }
          }
        });
        html += `</p>`;
      } else {
        // ── Normal mode: rendered LaTeX, click to edit ──
        const clickHandler = hasPendingChanges ? '' : ` onclick="if(window.getSelection().isCollapsed){state.editingPara=${pi};render()}"`;
        html += `<p class="paragraph paragraph-normal" data-para="${pi}"${clickHandler}>`;
        para.segments.forEach((seg, si) => {
          if (seg.type === "change" && seg.status === "pending") {
            html += `<span class="change-pending-normal">${renderLatex(seg.newContent)}</span>`;
          } else if (seg.flash) {
            html += `<span class="change-flash">${renderLatex(seg.content)}</span>`;
          } else {
            const content = seg.content;
            const paraComments = state.comments.filter(c => c.paraIndex === pi);
            if (paraComments.length === 0) {
              html += renderLatex(content);
            } else {
              let offset = 0;
              for (let j = 0; j < si; j++) {
                const s = para.segments[j];
                offset += s.type === "text" ? s.content.length : (s.oldContent || s.content || "").length;
              }
              const segStart = offset;
              const segEnd = segStart + content.length;
              const overlapping = paraComments
                .filter(c => c.start < segEnd && c.end > segStart)
                .sort((a, b) => a.start - b.start);
              if (overlapping.length === 0) {
                html += renderLatex(content);
              } else {
                let cursor = 0;
                for (const c of overlapping) {
                  const relStart = Math.max(0, c.start - segStart);
                  const relEnd = Math.min(content.length, c.end - segStart);
                  if (relStart > cursor) html += renderLatex(content.slice(cursor, relStart));
                  const color = COLORS[c.colorIdx % COLORS.length];
                  const isActive = state.activeCommentId === c.id;
                  html += `<span class="highlight${isActive ? ' active' : ''}" data-comment-id="${c.id}"
                    style="background:${color.bg};border-bottom:2px solid ${color.border};${isActive ? 'outline:2px solid ' + color.border + ';outline-offset:1px;' : ''}"
                    onclick="event.stopPropagation();state.activeCommentId=${state.activeCommentId === c.id ? 'null' : c.id};render()"
                  >${renderLatex(content.slice(relStart, relEnd))}</span>`;
                  cursor = relEnd;
                }
                if (cursor < content.length) html += renderLatex(content.slice(cursor));
              }
            }
          }
        });
        html += `</p>`;
      }
    } else {
      // ── Source mode: existing behavior ──
      const hasPendingChanges = para.segments.some(s => s.type === "change" && s.status === "pending");
      html += `<p class="paragraph" data-para="${pi}">`;

      para.segments.forEach((seg, si) => {
        if (seg.type === "change" && seg.status === "pending") {
          html += `<span class="change-old">${esc(seg.oldContent)}</span>`;
          html += `<span class="change-arrow"> → </span>`;
          html += `<span class="change-new">${esc(seg.newContent)}</span>`;
          html += `<button class="change-btn change-btn-accept" onclick="event.stopPropagation();acceptChange('${seg.id}')">✓</button>`;
          html += `<button class="change-btn change-btn-reject" onclick="event.stopPropagation();rejectChange('${seg.id}')">✕</button>`;
        } else if (seg.flash) {
          html += `<span class="change-flash">${esc(seg.content)}</span>`;
        } else {
          // Render with highlights
          const content = seg.content;
          const paraComments = state.comments.filter(c => c.paraIndex === pi);

          if (paraComments.length === 0) {
            html += esc(content);
          } else {
            // Calculate offset of this segment within the paragraph
            let offset = 0;
            for (let j = 0; j < si; j++) {
              const s = para.segments[j];
              offset += s.type === "text" ? s.content.length : (s.oldContent || s.content || "").length;
            }

            const segStart = offset;
            const segEnd = segStart + content.length;
            const overlapping = paraComments
              .filter(c => c.start < segEnd && c.end > segStart)
              .sort((a, b) => a.start - b.start);

            if (overlapping.length === 0) {
              html += esc(content);
            } else {
              let cursor = 0;
              for (const c of overlapping) {
                const relStart = Math.max(0, c.start - segStart);
                const relEnd = Math.min(content.length, c.end - segStart);
                if (relStart > cursor) html += esc(content.slice(cursor, relStart));
                const color = COLORS[c.colorIdx % COLORS.length];
                const isActive = state.activeCommentId === c.id;
                html += `<span class="highlight${isActive ? ' active' : ''}" data-comment-id="${c.id}"
                  style="background:${color.bg};border-bottom:2px solid ${color.border};${isActive ? 'outline:2px solid ' + color.border + ';outline-offset:1px;' : ''}"
                  onclick="event.stopPropagation();state.activeCommentId=${state.activeCommentId === c.id ? 'null' : c.id};render()"
                >${esc(content.slice(relStart, relEnd))}</span>`;
                cursor = relEnd;
              }
              if (cursor < content.length) html += esc(content.slice(cursor));
            }
          }
        }
      });

      html += `</p>`;
    }
  });
  html += `</div>`; // .document
  html += `</div>`; // .doc-column

  // Sidebar (always rendered to keep layout stable)
  html += `<div class="sidebar">`;
  if (state.comments.length > 0) {
    html += `<div class="sidebar-title">Comments</div>`;
    state.comments.forEach(c => {
      const color = COLORS[c.colorIdx % COLORS.length];
      const isActive = state.activeCommentId === c.id;
      const quote = c.selectedText.length > 35 ? c.selectedText.slice(0, 35) + "…" : c.selectedText;
      html += `<div class="margin-comment" data-sidebar-comment="${c.id}"
        style="border-left:3px solid ${color.border};background:${isActive ? color.bg : 'rgba(248,250,252,0.8)'}"
        onclick="state.activeCommentId=${state.activeCommentId === c.id ? 'null' : c.id};render()">
        <div class="margin-comment-quote">
          <span>"${esc(quote)}"</span>
          <button class="margin-comment-delete" onclick="event.stopPropagation();deleteComment(${c.id})">×</button>
        </div>
        <div class="margin-comment-text">${esc(c.comment)}</div>
      </div>`;
    });
  }
  html += `</div>`;

  html += `</div>`; // layout
  } // end if paragraphs.length > 0

  // Loading
  if (state.loading) {
    html += `<div class="loading-overlay">
      <div class="loading-box">
        <div class="spinner"></div>
        <div style="font-size:14px;font-weight:600;color:#1e293b">Requesting revision…</div>
        <div style="font-size:12px;color:#64748b;margin-top:4px">Claude is reviewing your comments</div>
      </div>
    </div>`;
  }

  // Toast
  if (state.toast) {
    html += `<div class="toast${state.toast.isError ? ' error' : ''}">${esc(state.toast.msg)}</div>`;
  }

  app.innerHTML = html;

  // Attach input + keydown listeners for direct text editing
  const docEl = app.querySelector(".document");
  if (docEl && state.viewMode === "source") {
    docEl.oninput = handleInput;
    docEl.onkeydown = handleKeyDown;
    docEl.onpaste = handlePaste;
    docEl.oncopy = handleCopy;
    // Prevent edits in paragraphs with pending changes (paste is handled by handlePaste)
    docEl.addEventListener("beforeinput", (e) => {
      if (e.inputType === "insertFromPaste" || e.inputType === "insertFromDrop") return;
      const sel = window.getSelection();
      if (!sel || !sel.rangeCount) return;
      let node = sel.anchorNode;
      while (node && !(node.dataset && node.dataset.para !== undefined)) {
        node = node.parentElement;
      }
      if (!node) return;
      const pi = parseInt(node.dataset.para);
      const para = state.paragraphs[pi];
      if (para && para.segments.some(s => s.type === "change" && s.status === "pending")) {
        e.preventDefault();
      }
    });
  }

  // Normal mode: attach oncopy and beforeinput guard
  if (docEl && state.viewMode === "normal") {
    docEl.oncopy = handleCopy;
    // Prevent edits outside the editing paragraph (paste is handled by handlePaste)
    docEl.addEventListener("beforeinput", (e) => {
      if (e.inputType === "insertFromPaste" || e.inputType === "insertFromDrop") return;
      if (state.editingPara === null) { e.preventDefault(); return; }
      const sel = window.getSelection();
      if (!sel || !sel.rangeCount) { e.preventDefault(); return; }
      let node = sel.anchorNode;
      while (node && !(node.dataset && node.dataset.para !== undefined)) {
        node = node.parentElement;
      }
      if (!node || parseInt(node.dataset.para) !== state.editingPara) {
        e.preventDefault();
      }
    });
  }

  // Normal mode: attach handlers for the editing paragraph
  if (docEl && state.viewMode === "normal" && state.editingPara !== null) {
    docEl.oninput = handleInput;
    docEl.onkeydown = handleKeyDown;
    docEl.onpaste = handlePaste;
    docEl.oncopy = handleCopy;
    const editingNode = docEl.querySelector(`.paragraph-editing[data-para="${state.editingPara}"]`);
    if (editingNode) {
      // Focus the document (contenteditable host) and position cursor in editing paragraph
      docEl.focus();
      const range = document.createRange();
      range.selectNodeContents(editingNode);
      range.collapse(true);
      const initSel = window.getSelection();
      initSel.removeAllRanges();
      initSel.addRange(range);
      const blurredPara = state.editingPara;
      docEl.addEventListener("blur", () => {
        setTimeout(() => {
          // If user clicked a different paragraph, editingPara already changed — don't reset
          if (state.editingPara !== blurredPara) return;
          // If user has an active text selection (e.g. drag-selecting across paragraphs), don't close
          const sel = window.getSelection();
          if (sel && !sel.isCollapsed) return;
          const active = document.activeElement;
          const toolbar = document.getElementById("selection-toolbar");
          const card = document.getElementById("comment-card");
          if (toolbar && toolbar.contains(active)) return;
          if (card && card.contains(active)) return;
          state.editingPara = null;
          render();
        }, 50);
      });
    }
  }

  alignSidebarComments();
}

function alignSidebarComments() {
  const sidebar = document.querySelector(".sidebar");
  const docEl = document.querySelector(".document");
  if (!sidebar || !docEl) return;

  const docRect = docEl.getBoundingClientRect();
  const sidebarRect = sidebar.getBoundingClientRect();
  let minNextTop = 0; // prevent overlap

  state.comments.forEach(c => {
    const highlight = docEl.querySelector(`[data-comment-id="${c.id}"]`);
    const card = sidebar.querySelector(`[data-sidebar-comment="${c.id}"]`);
    if (!highlight || !card) return;

    const highlightRect = highlight.getBoundingClientRect();
    // Target top relative to the sidebar's top
    const desiredTop = highlightRect.top - sidebarRect.top;
    const top = Math.max(desiredTop, minNextTop);
    card.style.top = top + "px";
    minNextTop = top + card.offsetHeight + 6;
  });

  // Set sidebar min-height so it encompasses all positioned comments
  if (state.comments.length > 0) {
    sidebar.style.minHeight = minNextTop + "px";
  }
}

function esc(str) {
  const div = document.createElement("div");
  div.textContent = str;
  return div.innerHTML;
}

// ── LaTeX rendering ────────────────────────────────────
const latexCache = new Map();

function renderLatex(text) {
  if (typeof katex === "undefined") return esc(text);

  const cached = latexCache.get(text);
  if (cached !== undefined) return cached;

  let result = esc(text);

  // Display math: $$...$$
  result = result.replace(/\$\$([\s\S]*?)\$\$/g, (_, math) => {
    try {
      return katex.renderToString(unesc(math), { displayMode: true, throwOnError: false });
    } catch { return `<span class="latex-error">$$${math}$$</span>`; }
  });

  // Inline math: $...$  (but not \$)
  result = result.replace(/(?<!\$)\$(?!\$)(.+?)(?<!\$)\$(?!\$)/g, (_, math) => {
    try {
      return katex.renderToString(unesc(math), { displayMode: false, throwOnError: false });
    } catch { return `<span class="latex-error">$${math}$</span>`; }
  });

  // \section{...}
  result = result.replace(/\\section\{([^}]*)\}/g, '<span class="latex-section">$1</span>');

  // \subsection{...}
  result = result.replace(/\\subsection\{([^}]*)\}/g, '<span class="latex-subsection">$1</span>');

  // \textbf{...}
  result = result.replace(/\\textbf\{([^}]*)\}/g, '<strong>$1</strong>');

  // \textit{...}
  result = result.replace(/\\textit\{([^}]*)\}/g, '<em>$1</em>');

  // \underline{...}
  result = result.replace(/\\underline\{([^}]*)\}/g, '<u>$1</u>');

  // \emph{...}
  result = result.replace(/\\emph\{([^}]*)\}/g, '<em>$1</em>');

  // LaTeX escape sequences: \% \$ \& \# \_ \{ \}
  result = result.replace(/\\%/g, '%');
  result = result.replace(/\\\$/g, '$');
  result = result.replace(/\\&amp;/g, '&amp;');  // esc() turned & into &amp;
  result = result.replace(/\\#/g, '#');
  result = result.replace(/\\_/g, '_');
  result = result.replace(/\\\{/g, '{');
  result = result.replace(/\\\}/g, '}');

  // Typographic dashes: --- → em dash, -- → en dash (order matters)
  result = result.replace(/---/g, '\u2014');
  result = result.replace(/--/g, '\u2013');

  // ~ → non-breaking space (LaTeX tie)
  result = result.replace(/~/g, '&nbsp;');

  // Catch-all: remaining \command{...} or \command → grey pill
  result = result.replace(/\\([a-zA-Z]+)\{([^}]*)\}/g,
    (m, cmd, arg) => `<span class="latex-markup">\\${cmd}{${arg}}</span>`);
  result = result.replace(/\\([a-zA-Z]+)(?![{a-zA-Z])/g,
    (m, cmd) => `<span class="latex-markup">\\${cmd}</span>`);

  // Cap cache size
  if (latexCache.size > 500) latexCache.clear();
  latexCache.set(text, result);
  return result;
}

function unesc(html) {
  const el = document.createElement("textarea");
  el.innerHTML = html;
  return el.value;
}

// ── Init ───────────────────────────────────────────────
(async function init() {
  const params = new URLSearchParams(window.location.search);
  const docParam = params.get("doc");
  if (docParam) {
    await openDocument(parseInt(docParam, 10));
  } else {
    fetchDocList();
    render();
  }
})();

// Warn on close if save is pending
window.addEventListener("beforeunload", (e) => {
  if (state.saveStatus === "unsaved" || state.saveStatus === "saving") {
    e.preventDefault();
  }
});

// Browser back/forward
window.addEventListener("popstate", () => {
  const params = new URLSearchParams(window.location.search);
  const docParam = params.get("doc");
  if (docParam) {
    openDocument(parseInt(docParam, 10));
  } else {
    newDocument();
  }
});

// Document-level listeners (persist across render cycles)
document.addEventListener("mouseup", handleMouseUp);

document.addEventListener("mousedown", function(e) {
  const toolbar = document.getElementById("selection-toolbar");
  const card = document.getElementById("comment-card");
  if (toolbar.contains(e.target) || card.contains(e.target)) return;
  if (toolbar.classList.contains("visible") && !card.classList.contains("visible")) {
    hideSelectionToolbar();
  }
});

// Toggle Source/Normal mode with Cmd+Shift+M (Mac) / Ctrl+Shift+M
document.addEventListener("keydown", function(e) {
  if (e.key === "M" && e.shiftKey && (e.metaKey || e.ctrlKey)) {
    e.preventDefault();
    if (state.paragraphs.length === 0) return;
    state.viewMode = state.viewMode === "source" ? "normal" : "source";
    state.editingPara = null;
    latexCache.clear();
    render();
  }
});

// Handle keyboard shortcuts in comment card
document.getElementById("comment-input").addEventListener("keydown", function(e) {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    submitComment();
  }
  if (e.key === "Escape") {
    closeCommentCard();
  }
});
</script>

</body>
</html>
